/**
 * Perun RPC API
 * Perun Remote Procedure Calls Application Programming Interface
 *
 * The version of the OpenAPI document: 3.9.0
 * Contact: perun@cesnet.cz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { Attribute } from '../model/attribute';
import { AttributeDefinition } from '../model/attributeDefinition';
import { InputCreateAttributeDefinition } from '../model/inputCreateAttributeDefinition';
import { InputEntitylessAttribute } from '../model/inputEntitylessAttribute';
import { InputSetFacilityAttribute } from '../model/inputSetFacilityAttribute';
import { InputSetFacilityAttributes } from '../model/inputSetFacilityAttributes';
import { InputSetFacilityResourceGroupUserMemberAttributes } from '../model/inputSetFacilityResourceGroupUserMemberAttributes';
import { InputSetFacilityResourceUserMemberAttributes } from '../model/inputSetFacilityResourceUserMemberAttributes';
import { InputSetFacilityUserAttributes } from '../model/inputSetFacilityUserAttributes';
import { InputSetGroupAttribute } from '../model/inputSetGroupAttribute';
import { InputSetGroupAttributes } from '../model/inputSetGroupAttributes';
import { InputSetGroupResourceAttribute } from '../model/inputSetGroupResourceAttribute';
import { InputSetHostAttribute } from '../model/inputSetHostAttribute';
import { InputSetHostAttributes } from '../model/inputSetHostAttributes';
import { InputSetMemberAttribute } from '../model/inputSetMemberAttribute';
import { InputSetMemberAttributes } from '../model/inputSetMemberAttributes';
import { InputSetMemberGroupAttribute } from '../model/inputSetMemberGroupAttribute';
import { InputSetMemberGroupAttributes } from '../model/inputSetMemberGroupAttributes';
import { InputSetMemberGroupWithUserAttributes } from '../model/inputSetMemberGroupWithUserAttributes';
import { InputSetMemberResourceAndUserAttributes } from '../model/inputSetMemberResourceAndUserAttributes';
import { InputSetMemberResourceAttribute } from '../model/inputSetMemberResourceAttribute';
import { InputSetMemberResourceAttributes } from '../model/inputSetMemberResourceAttributes';
import { InputSetMemberWithUserAttributes } from '../model/inputSetMemberWithUserAttributes';
import { InputSetResourceAttribute } from '../model/inputSetResourceAttribute';
import { InputSetResourceAttributes } from '../model/inputSetResourceAttributes';
import { InputSetResourceGroupAttributes } from '../model/inputSetResourceGroupAttributes';
import { InputSetResourceGroupWithGroupAttributes } from '../model/inputSetResourceGroupWithGroupAttributes';
import { InputSetUserAttribute } from '../model/inputSetUserAttribute';
import { InputSetUserAttributes } from '../model/inputSetUserAttributes';
import { InputSetUserExtSourceAttribute } from '../model/inputSetUserExtSourceAttribute';
import { InputSetUserExtSourceAttributes } from '../model/inputSetUserExtSourceAttributes';
import { InputSetUserFacilityAttribute } from '../model/inputSetUserFacilityAttribute';
import { InputSetVoAttribute } from '../model/inputSetVoAttribute';
import { InputSetVoAttributes } from '../model/inputSetVoAttributes';
import { PerunException } from '../model/perunException';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class AttributesManagerService {

    protected basePath = 'https://perun.cesnet.cz/krb/rpc';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    /**
     * Creates AttributeDefinition.
     * @param inputCreateAttributeDefinition 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createAttributeDefinition(inputCreateAttributeDefinition: InputCreateAttributeDefinition, observe?: 'body', reportProgress?: boolean): Observable<AttributeDefinition>;
    public createAttributeDefinition(inputCreateAttributeDefinition: InputCreateAttributeDefinition, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AttributeDefinition>>;
    public createAttributeDefinition(inputCreateAttributeDefinition: InputCreateAttributeDefinition, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AttributeDefinition>>;
    public createAttributeDefinition(inputCreateAttributeDefinition: InputCreateAttributeDefinition, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputCreateAttributeDefinition === null || inputCreateAttributeDefinition === undefined) {
            throw new Error('Required parameter inputCreateAttributeDefinition was null or undefined when calling createAttributeDefinition.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<AttributeDefinition>(`${this.configuration.basePath}/json/attributesManager/createAttribute`,
            inputCreateAttributeDefinition,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes attribute definition from Perun including all values set for any entity.
     * @param attribute id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAttributeDefinition(attribute: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteAttributeDefinition(attribute: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteAttributeDefinition(attribute: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteAttributeDefinition(attribute: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (attribute === null || attribute === undefined) {
            throw new Error('Required parameter attribute was null or undefined when calling deleteAttributeDefinition.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (attribute !== undefined && attribute !== null) {
            queryParameters = queryParameters.set('attribute', <any>attribute);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.post<any>(`${this.configuration.basePath}/urlinjsonout/attributesManager/deleteAttribute`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes attribute definitions from Perun including all values set for any entity.
     * @param attributes list of attribute ids List&lt;Integer&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAttributeDefinitions(attributes: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteAttributeDefinitions(attributes: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteAttributeDefinitions(attributes: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteAttributeDefinitions(attributes: Array<number>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (attributes === null || attributes === undefined) {
            throw new Error('Required parameter attributes was null or undefined when calling deleteAttributeDefinitions.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (attributes) {
            attributes.forEach((element) => {
                queryParameters = queryParameters.append('attributes[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.post<any>(`${this.configuration.basePath}/urlinjsonout/attributesManager/deleteAttributes`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all AttributeDefinitions.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllAttributeDefinitions(observe?: 'body', reportProgress?: boolean): Observable<Array<AttributeDefinition>>;
    public getAllAttributeDefinitions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AttributeDefinition>>>;
    public getAllAttributeDefinitions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AttributeDefinition>>>;
    public getAllAttributeDefinitions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<AttributeDefinition>>(`${this.configuration.basePath}/json/attributesManager/getAttributesDefinition`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an Attribute by its name or id.
     * This method cannot be fully described correctly in OpenID, because it cannot describe allowed combinations of parameters. One of attributeName, attributeId is required. The other parameters specify ids that can be combined in the following ways:  (facility), (user), (user,facility), (vo), (member), (group), (resource),  (member,group), (member,resource), (group,resource),(userExtSource), (host), (key) Use the specialized methods getFacilityAttributeByName(), getMemberResourceAttributeById() etc. 
     * @param attributeName full name of attribute (namespace + \&#39;:\&#39; + friendlyName)
     * @param attributeId id of attribute
     * @param facility id of Facility
     * @param user id of User
     * @param vo id of Vo
     * @param resource id of Resource
     * @param member id of Member
     * @param group id of Group
     * @param host id of Host
     * @param userExtSource id of UserExtSource
     * @param key key for entityless attribute
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAttribute(attributeName?: string, attributeId?: number, facility?: number, user?: number, vo?: number, resource?: number, member?: number, group?: number, host?: number, userExtSource?: number, key?: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getAttribute(attributeName?: string, attributeId?: number, facility?: number, user?: number, vo?: number, resource?: number, member?: number, group?: number, host?: number, userExtSource?: number, key?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getAttribute(attributeName?: string, attributeId?: number, facility?: number, user?: number, vo?: number, resource?: number, member?: number, group?: number, host?: number, userExtSource?: number, key?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getAttribute(attributeName?: string, attributeId?: number, facility?: number, user?: number, vo?: number, resource?: number, member?: number, group?: number, host?: number, userExtSource?: number, key?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }
        if (facility !== undefined && facility !== null) {
            queryParameters = queryParameters.set('facility', <any>facility);
        }
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (vo !== undefined && vo !== null) {
            queryParameters = queryParameters.set('vo', <any>vo);
        }
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (host !== undefined && host !== null) {
            queryParameters = queryParameters.set('host', <any>host);
        }
        if (userExtSource !== undefined && userExtSource !== null) {
            queryParameters = queryParameters.set('userExtSource', <any>userExtSource);
        }
        if (key !== undefined && key !== null) {
            queryParameters = queryParameters.set('key', <any>key);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/any`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an AttributeDefinition by its id.
     * @param id numeric id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAttributeDefinitionById(id: number, observe?: 'body', reportProgress?: boolean): Observable<AttributeDefinition>;
    public getAttributeDefinitionById(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AttributeDefinition>>;
    public getAttributeDefinitionById(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AttributeDefinition>>;
    public getAttributeDefinitionById(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAttributeDefinitionById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<AttributeDefinition>(`${this.configuration.basePath}/json/attributesManager/getAttributeDefinitionById`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an AttributeDefinition by its name.
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAttributeDefinitionByName(attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<AttributeDefinition>;
    public getAttributeDefinitionByName(attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AttributeDefinition>>;
    public getAttributeDefinitionByName(attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AttributeDefinition>>;
    public getAttributeDefinitionByName(attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getAttributeDefinitionByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<AttributeDefinition>(`${this.configuration.basePath}/json/attributesManager/getAttributeDefinition`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all AttributeDefinitions in a namespace.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAttributeDefinitionsByNamespace(observe?: 'body', reportProgress?: boolean): Observable<Array<AttributeDefinition>>;
    public getAttributeDefinitionsByNamespace(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AttributeDefinition>>>;
    public getAttributeDefinitionsByNamespace(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AttributeDefinition>>>;
    public getAttributeDefinitionsByNamespace(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<AttributeDefinition>>(`${this.configuration.basePath}/json/attributesManager/getAttributesDefinitionByNamespace`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an entityless Attribute by its name.
     * This is an overloaded method getAttribute, specialized for entityless key and attribute name.
     * @param key key for entityless attribute
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntitylessAttributeByName(key: string, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getEntitylessAttributeByName(key: string, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getEntitylessAttributeByName(key: string, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getEntitylessAttributeByName(key: string, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getEntitylessAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getEntitylessAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (key !== undefined && key !== null) {
            queryParameters = queryParameters.set('key', <any>key);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-entityless`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all entityless attributes with subject equaled String key. 
     * @param key key for entityless attributes
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntitylessAttributesByKey(key: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getEntitylessAttributesByKey(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getEntitylessAttributesByKey(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getEntitylessAttributesByKey(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getEntitylessAttributesByKey.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (key !== undefined && key !== null) {
            queryParameters = queryParameters.set('key', <any>key);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/key`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all entityless attributes with attrName.
     * @param attrName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntitylessAttributesByName(attrName: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getEntitylessAttributesByName(attrName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getEntitylessAttributesByName(attrName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getEntitylessAttributesByName(attrName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (attrName === null || attrName === undefined) {
            throw new Error('Required parameter attrName was null or undefined when calling getEntitylessAttributesByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (attrName !== undefined && attrName !== null) {
            queryParameters = queryParameters.set('attrName', <any>attrName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getEntitylessAttributes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of Keys which fits the attributeDefinition.
     * @param attributeDefinition id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntitylessKeys(attributeDefinition: number, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public getEntitylessKeys(attributeDefinition: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public getEntitylessKeys(attributeDefinition: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public getEntitylessKeys(attributeDefinition: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (attributeDefinition === null || attributeDefinition === undefined) {
            throw new Error('Required parameter attributeDefinition was null or undefined when calling getEntitylessKeys.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (attributeDefinition !== undefined && attributeDefinition !== null) {
            queryParameters = queryParameters.set('attributeDefinition', <any>attributeDefinition);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<string>>(`${this.configuration.basePath}/json/attributesManager/getEntitylessKeys`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a facility Attribute by its id.
     * This is an overloaded method getAttribute, specialized for facility and attribute id.
     * @param facility id of Facility
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacilityAttributeById(facility: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getFacilityAttributeById(facility: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getFacilityAttributeById(facility: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getFacilityAttributeById(facility: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (facility === null || facility === undefined) {
            throw new Error('Required parameter facility was null or undefined when calling getFacilityAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getFacilityAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (facility !== undefined && facility !== null) {
            queryParameters = queryParameters.set('facility', <any>facility);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-facility`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a facility Attribute by its name.
     * This is an overloaded method getAttribute, specialized for facility and attribute name.
     * @param facility id of Facility
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacilityAttributeByName(facility: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getFacilityAttributeByName(facility: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getFacilityAttributeByName(facility: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getFacilityAttributeByName(facility: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (facility === null || facility === undefined) {
            throw new Error('Required parameter facility was null or undefined when calling getFacilityAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getFacilityAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (facility !== undefined && facility !== null) {
            queryParameters = queryParameters.set('facility', <any>facility);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-facility`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all non-empty Facility attributes for selected Facility.
     * @param facility id of Facility
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacilityAttributes(facility: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getFacilityAttributes(facility: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getFacilityAttributes(facility: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getFacilityAttributes(facility: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (facility === null || facility === undefined) {
            throw new Error('Required parameter facility was null or undefined when calling getFacilityAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (facility !== undefined && facility !== null) {
            queryParameters = queryParameters.set('facility', <any>facility);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/f`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all specified Facility attributes for selected Facility.
     * @param facility id of Facility
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacilityAttributesByNames(facility: number, attrNames: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getFacilityAttributesByNames(facility: number, attrNames: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getFacilityAttributesByNames(facility: number, attrNames: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getFacilityAttributesByNames(facility: number, attrNames: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (facility === null || facility === undefined) {
            throw new Error('Required parameter facility was null or undefined when calling getFacilityAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getFacilityAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (facility !== undefined && facility !== null) {
            queryParameters = queryParameters.set('facility', <any>facility);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/f-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty member, user, member-resource and user-facility attributes.
     * @param facility id of Facility
     * @param resource id of Resource
     * @param user id of User
     * @param member id of Member
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacilityResourceUserMemberAttributes(facility: number, resource: number, user: number, member: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getFacilityResourceUserMemberAttributes(facility: number, resource: number, user: number, member: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getFacilityResourceUserMemberAttributes(facility: number, resource: number, user: number, member: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getFacilityResourceUserMemberAttributes(facility: number, resource: number, user: number, member: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (facility === null || facility === undefined) {
            throw new Error('Required parameter facility was null or undefined when calling getFacilityResourceUserMemberAttributes.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getFacilityResourceUserMemberAttributes.');
        }
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getFacilityResourceUserMemberAttributes.');
        }
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getFacilityResourceUserMemberAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (facility !== undefined && facility !== null) {
            queryParameters = queryParameters.set('facility', <any>facility);
        }
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/f-r-u-m`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the user on the facility.
     * @param facility id of Facility
     * @param user id of User
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacilityUserAttributes(facility: number, user: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getFacilityUserAttributes(facility: number, user: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getFacilityUserAttributes(facility: number, user: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getFacilityUserAttributes(facility: number, user: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (facility === null || facility === undefined) {
            throw new Error('Required parameter facility was null or undefined when calling getFacilityUserAttributes.');
        }
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getFacilityUserAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (facility !== undefined && facility !== null) {
            queryParameters = queryParameters.set('facility', <any>facility);
        }
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/f-u`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a group Attribute by its id.
     * This is an overloaded method getAttribute, specialized for group and attribute id.
     * @param group id of Group
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGroupAttributeById(group: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getGroupAttributeById(group: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getGroupAttributeById(group: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getGroupAttributeById(group: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroupAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getGroupAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-group`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a group Attribute by its name.
     * This is an overloaded method getAttribute, specialized for group and attribute name.
     * @param group id of Group
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGroupAttributeByName(group: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getGroupAttributeByName(group: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getGroupAttributeByName(group: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getGroupAttributeByName(group: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroupAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getGroupAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-group`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the group. 
     * @param group id of Group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGroupAttributes(group: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getGroupAttributes(group: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getGroupAttributes(group: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getGroupAttributes(group: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroupAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/g`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the group which have name in list attrNames (empty too). Virtual attribute too. 
     * @param group id of Group
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGroupAttributesByNames(group: number, attrNames: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getGroupAttributesByNames(group: number, attrNames: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getGroupAttributesByNames(group: number, attrNames: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getGroupAttributesByNames(group: number, attrNames: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroupAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getGroupAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/g-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a group_resource Attribute by its id.
     * This is an overloaded method getAttribute, specialized for group, resource and attribute id.
     * @param group id of Group
     * @param resource id of Resource
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGroupResourceAttributeById(group: number, resource: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getGroupResourceAttributeById(group: number, resource: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getGroupResourceAttributeById(group: number, resource: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getGroupResourceAttributeById(group: number, resource: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroupResourceAttributeById.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getGroupResourceAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getGroupResourceAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-group-resource`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a group_resource Attribute by its name.
     * This is an overloaded method getAttribute, specialized for group, resource and attribute name.
     * @param group id of Group
     * @param resource id of Resource
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGroupResourceAttributeByName(group: number, resource: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getGroupResourceAttributeByName(group: number, resource: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getGroupResourceAttributeByName(group: number, resource: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getGroupResourceAttributeByName(group: number, resource: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroupResourceAttributeByName.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getGroupResourceAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getGroupResourceAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-group-resource`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a host Attribute by its id.
     * This is an overloaded method getAttribute, specialized for host and attribute id.
     * @param host id of Host
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHostAttributeById(host: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getHostAttributeById(host: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getHostAttributeById(host: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getHostAttributeById(host: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (host === null || host === undefined) {
            throw new Error('Required parameter host was null or undefined when calling getHostAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getHostAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (host !== undefined && host !== null) {
            queryParameters = queryParameters.set('host', <any>host);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-host`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a host Attribute by its name.
     * This is an overloaded method getAttribute, specialized for host and attribute name.
     * @param host id of Host
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHostAttributeByName(host: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getHostAttributeByName(host: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getHostAttributeByName(host: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getHostAttributeByName(host: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (host === null || host === undefined) {
            throw new Error('Required parameter host was null or undefined when calling getHostAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getHostAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (host !== undefined && host !== null) {
            queryParameters = queryParameters.set('host', <any>host);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-host`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the host. 
     * @param host id of Host
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHostAttributes(host: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getHostAttributes(host: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getHostAttributes(host: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getHostAttributes(host: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (host === null || host === undefined) {
            throw new Error('Required parameter host was null or undefined when calling getHostAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (host !== undefined && host !== null) {
            queryParameters = queryParameters.set('host', <any>host);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/h`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the member and if workWithUserAttributes is true, get all non-empty attributes associated with user, who is this member. 
     * @param member id of Member
     * @param workWithUserAttributes flag to work with user attributes
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberAndUserAttributes(member: number, workWithUserAttributes: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberAndUserAttributes(member: number, workWithUserAttributes: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberAndUserAttributes(member: number, workWithUserAttributes: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberAndUserAttributes(member: number, workWithUserAttributes: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberAndUserAttributes.');
        }
        if (workWithUserAttributes === null || workWithUserAttributes === undefined) {
            throw new Error('Required parameter workWithUserAttributes was null or undefined when calling getMemberAndUserAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (workWithUserAttributes !== undefined && workWithUserAttributes !== null) {
            queryParameters = queryParameters.set('workWithUserAttributes', <any>workWithUserAttributes);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m-wu`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the member which have name in list attrNames (empty too). Virtual attributes too. If workWithUserAttribute is true, return also all user attributes in list of attrNames (with virtual attributes too). 
     * @param member id of Member
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param workWithUserAttributes flag to work with user attributes
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberAndUserAttributesByNames(member: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberAndUserAttributesByNames(member: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberAndUserAttributesByNames(member: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberAndUserAttributesByNames(member: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberAndUserAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getMemberAndUserAttributesByNames.');
        }
        if (workWithUserAttributes === null || workWithUserAttributes === undefined) {
            throw new Error('Required parameter workWithUserAttributes was null or undefined when calling getMemberAndUserAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }
        if (workWithUserAttributes !== undefined && workWithUserAttributes !== null) {
            queryParameters = queryParameters.set('workWithUserAttributes', <any>workWithUserAttributes);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m-names-wu`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a member Attribute by its id.
     * This is an overloaded method getAttribute, specialized for member and attribute id.
     * @param member id of Member
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberAttributeById(member: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getMemberAttributeById(member: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getMemberAttributeById(member: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getMemberAttributeById(member: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getMemberAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-member`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a member Attribute by its name.
     * This is an overloaded method getAttribute, specialized for member and attribute name.
     * @param member id of Member
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberAttributeByName(member: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getMemberAttributeByName(member: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getMemberAttributeByName(member: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getMemberAttributeByName(member: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getMemberAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-member`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the member. 
     * @param member id of Member
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberAttributes(member: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberAttributes(member: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberAttributes(member: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberAttributes(member: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the member which have name in list attrNames (empty too). Virtual attribute too. 
     * @param member id of Member
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberAttributesByNames(member: number, attrNames: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberAttributesByNames(member: number, attrNames: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberAttributesByNames(member: number, attrNames: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberAttributesByNames(member: number, attrNames: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getMemberAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the member in the group which have name in list attrNames (empty too). If workWithUserAttribute is true, return also all user attributes in list of attrNames (with virtual attributes too). 
     * @param member id of Member
     * @param group id of Group
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param workWithUserAttributes flag to work with user attributes
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberGroupAndUserAttributesByNames(member: number, group: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberGroupAndUserAttributesByNames(member: number, group: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberGroupAndUserAttributesByNames(member: number, group: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberGroupAndUserAttributesByNames(member: number, group: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberGroupAndUserAttributesByNames.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getMemberGroupAndUserAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getMemberGroupAndUserAttributesByNames.');
        }
        if (workWithUserAttributes === null || workWithUserAttributes === undefined) {
            throw new Error('Required parameter workWithUserAttributes was null or undefined when calling getMemberGroupAndUserAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }
        if (workWithUserAttributes !== undefined && workWithUserAttributes !== null) {
            queryParameters = queryParameters.set('workWithUserAttributes', <any>workWithUserAttributes);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m-g-names-wu`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a member_group Attribute by its id.
     * This is an overloaded method getAttribute, specialized for member, group and attribute id.
     * @param member id of Member
     * @param group id of Group
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberGroupAttributeById(member: number, group: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getMemberGroupAttributeById(member: number, group: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getMemberGroupAttributeById(member: number, group: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getMemberGroupAttributeById(member: number, group: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberGroupAttributeById.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getMemberGroupAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getMemberGroupAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-member-group`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a member_group Attribute by its name.
     * This is an overloaded method getAttribute, specialized for member, group and attribute name.
     * @param member id of Member
     * @param group id of Group
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberGroupAttributeByName(member: number, group: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getMemberGroupAttributeByName(member: number, group: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getMemberGroupAttributeByName(member: number, group: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getMemberGroupAttributeByName(member: number, group: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberGroupAttributeByName.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getMemberGroupAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getMemberGroupAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-member-group`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the member in the group. 
     * @param member id of Member
     * @param group id of Group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberGroupAttributes(member: number, group: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberGroupAttributes(member: number, group: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberGroupAttributes(member: number, group: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberGroupAttributes(member: number, group: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberGroupAttributes.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getMemberGroupAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m-g`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes (empty and virtual too)associated with the member in the group which have name in list attrNames. 
     * @param member id of Member
     * @param group id of Group
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberGroupAttributesByNames(member: number, group: number, attrNames: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberGroupAttributesByNames(member: number, group: number, attrNames: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberGroupAttributesByNames(member: number, group: number, attrNames: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberGroupAttributesByNames(member: number, group: number, attrNames: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberGroupAttributesByNames.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getMemberGroupAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getMemberGroupAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m-g-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all non-empty attributes associated with the member on the resource and if workWithUserAttributes is true, gets also all non-empty user, user-facility and member attributes. 
     * @param member id of Member
     * @param resource id of Resource
     * @param workWithUserAttributes flag to work with user attributes
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberResourceAndUserFacilityAttributes(member: number, resource: number, workWithUserAttributes: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberResourceAndUserFacilityAttributes(member: number, resource: number, workWithUserAttributes: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberResourceAndUserFacilityAttributes(member: number, resource: number, workWithUserAttributes: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberResourceAndUserFacilityAttributes(member: number, resource: number, workWithUserAttributes: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberResourceAndUserFacilityAttributes.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getMemberResourceAndUserFacilityAttributes.');
        }
        if (workWithUserAttributes === null || workWithUserAttributes === undefined) {
            throw new Error('Required parameter workWithUserAttributes was null or undefined when calling getMemberResourceAndUserFacilityAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (workWithUserAttributes !== undefined && workWithUserAttributes !== null) {
            queryParameters = queryParameters.set('workWithUserAttributes', <any>workWithUserAttributes);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m-r-wu`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets selected non-empty attributes associated with the member and the resource. It returns member and member-resource attributes and also user and user-facility attributes if workWithUserAttributes is true. Attributes are selected by list of attr_names. Empty list means all attributes. 
     * @param member id of Member
     * @param resource id of Resource
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param workWithUserAttributes flag to work with user attributes
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberResourceAndUserFacilityAttributesByNames(member: number, resource: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberResourceAndUserFacilityAttributesByNames(member: number, resource: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberResourceAndUserFacilityAttributesByNames(member: number, resource: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberResourceAndUserFacilityAttributesByNames(member: number, resource: number, attrNames: Array<string>, workWithUserAttributes: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberResourceAndUserFacilityAttributesByNames.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getMemberResourceAndUserFacilityAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getMemberResourceAndUserFacilityAttributesByNames.');
        }
        if (workWithUserAttributes === null || workWithUserAttributes === undefined) {
            throw new Error('Required parameter workWithUserAttributes was null or undefined when calling getMemberResourceAndUserFacilityAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }
        if (workWithUserAttributes !== undefined && workWithUserAttributes !== null) {
            queryParameters = queryParameters.set('workWithUserAttributes', <any>workWithUserAttributes);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m-r-names-wu`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a member_resource Attribute by its id.
     * This is an overloaded method getAttribute, specialized for member, resource and attribute id.
     * @param member id of Member
     * @param resource id of Resource
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberResourceAttributeById(member: number, resource: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getMemberResourceAttributeById(member: number, resource: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getMemberResourceAttributeById(member: number, resource: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getMemberResourceAttributeById(member: number, resource: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberResourceAttributeById.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getMemberResourceAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getMemberResourceAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-member-resource`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a member_resource Attribute by its name.
     * This is an overloaded method getAttribute, specialized for member, resource and attribute name.
     * @param member id of Member
     * @param resource id of Resource
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberResourceAttributeByName(member: number, resource: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getMemberResourceAttributeByName(member: number, resource: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getMemberResourceAttributeByName(member: number, resource: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getMemberResourceAttributeByName(member: number, resource: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberResourceAttributeByName.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getMemberResourceAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getMemberResourceAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-member-resource`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the member on the resource.
     * @param member id of Member
     * @param resource id of Resource
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberResourceAttributes(member: number, resource: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getMemberResourceAttributes(member: number, resource: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getMemberResourceAttributes(member: number, resource: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getMemberResourceAttributes(member: number, resource: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getMemberResourceAttributes.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getMemberResourceAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/m-r`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a resource Attribute by its id.
     * This is an overloaded method getAttribute, specialized for resource and attribute id.
     * @param resource id of Resource
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getResourceAttributeById(resource: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getResourceAttributeById(resource: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getResourceAttributeById(resource: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getResourceAttributeById(resource: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getResourceAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getResourceAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-resource`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a resource Attribute by its name.
     * This is an overloaded method getAttribute, specialized for resource and attribute name.
     * @param resource id of Resource
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getResourceAttributeByName(resource: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getResourceAttributeByName(resource: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getResourceAttributeByName(resource: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getResourceAttributeByName(resource: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getResourceAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getResourceAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-resource`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the resource.
     * @param resource id of Resource
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getResourceAttributes(resource: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getResourceAttributes(resource: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getResourceAttributes(resource: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getResourceAttributes(resource: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getResourceAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/r`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the resource which have name in list attrNames (empty too). Virtual attributes too. 
     * @param resource id of Resource
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getResourceAttributesByNames(resource: number, attrNames: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getResourceAttributesByNames(resource: number, attrNames: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getResourceAttributesByNames(resource: number, attrNames: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getResourceAttributesByNames(resource: number, attrNames: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getResourceAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getResourceAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/r-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the group and resource. Virtual attributes too. If workWithGroupAttributes is true, return also all group attributes. 
     * @param resource id of Resource
     * @param group id of Group
     * @param workWithGroupAttributes flag to work with group attributes
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getResourceGroupAndGroupAttributes(resource: number, group: number, workWithGroupAttributes: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getResourceGroupAndGroupAttributes(resource: number, group: number, workWithGroupAttributes: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getResourceGroupAndGroupAttributes(resource: number, group: number, workWithGroupAttributes: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getResourceGroupAndGroupAttributes(resource: number, group: number, workWithGroupAttributes: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getResourceGroupAndGroupAttributes.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getResourceGroupAndGroupAttributes.');
        }
        if (workWithGroupAttributes === null || workWithGroupAttributes === undefined) {
            throw new Error('Required parameter workWithGroupAttributes was null or undefined when calling getResourceGroupAndGroupAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (workWithGroupAttributes !== undefined && workWithGroupAttributes !== null) {
            queryParameters = queryParameters.set('workWithGroupAttributes', <any>workWithGroupAttributes);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/r-g-wg`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the group and the resource which have their name in list attrNames (empty too). Virtual attributes too. If workWithGroupAttributes is true, return also all group attributes in list of attrNames (with virtual attributes too). 
     * @param resource id of Resource
     * @param group id of Group
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param workWithGroupAttributes flag to work with group attributes
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getResourceGroupAndGroupAttributesByNames(resource: number, group: number, attrNames: Array<string>, workWithGroupAttributes: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getResourceGroupAndGroupAttributesByNames(resource: number, group: number, attrNames: Array<string>, workWithGroupAttributes: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getResourceGroupAndGroupAttributesByNames(resource: number, group: number, attrNames: Array<string>, workWithGroupAttributes: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getResourceGroupAndGroupAttributesByNames(resource: number, group: number, attrNames: Array<string>, workWithGroupAttributes: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getResourceGroupAndGroupAttributesByNames.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getResourceGroupAndGroupAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getResourceGroupAndGroupAttributesByNames.');
        }
        if (workWithGroupAttributes === null || workWithGroupAttributes === undefined) {
            throw new Error('Required parameter workWithGroupAttributes was null or undefined when calling getResourceGroupAndGroupAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }
        if (workWithGroupAttributes !== undefined && workWithGroupAttributes !== null) {
            queryParameters = queryParameters.set('workWithGroupAttributes', <any>workWithGroupAttributes);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/r-g-names-wg`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the group on resource.
     * @param resource id of Resource
     * @param group id of Group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getResourceGroupAttributes(resource: number, group: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getResourceGroupAttributes(resource: number, group: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getResourceGroupAttributes(resource: number, group: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getResourceGroupAttributes(resource: number, group: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getResourceGroupAttributes.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getResourceGroupAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/r-g`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes by the list of attrNames if they are in one of these namespaces: - member - group - member-group - resource - member-resource - group-resource - user (get from member object) - facility (get from resource object) - user-facility Returns all attributes even if they are empty or virtual. 
     * @param resource id of Resource
     * @param group id of Group
     * @param member id of Member
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getResourceGroupMemberAttributesByNames(resource: number, group: number, member: number, attrNames: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getResourceGroupMemberAttributesByNames(resource: number, group: number, member: number, attrNames: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getResourceGroupMemberAttributesByNames(resource: number, group: number, member: number, attrNames: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getResourceGroupMemberAttributesByNames(resource: number, group: number, member: number, attrNames: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getResourceGroupMemberAttributesByNames.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getResourceGroupMemberAttributesByNames.');
        }
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getResourceGroupMemberAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getResourceGroupMemberAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (resource !== undefined && resource !== null) {
            queryParameters = queryParameters.set('resource', <any>resource);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }
        if (member !== undefined && member !== null) {
            queryParameters = queryParameters.set('member', <any>member);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/r-g-m-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a user Attribute by its id.
     * This is an overloaded method getAttribute, specialized for user and attribute id.
     * @param user id of User
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserAttributeById(user: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getUserAttributeById(user: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getUserAttributeById(user: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getUserAttributeById(user: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getUserAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-user`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a user Attribute by its name.
     * This is an overloaded method getAttribute, specialized for user and attribute name.
     * @param user id of User
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserAttributeByName(user: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getUserAttributeByName(user: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getUserAttributeByName(user: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getUserAttributeByName(user: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getUserAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-user`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the user. 
     * @param user id of User
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserAttributes(user: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getUserAttributes(user: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getUserAttributes(user: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getUserAttributes(user: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/u`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the user which have name in list attrNames (empty too). 
     * @param user id of User
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserAttributesByNames(user: number, attrNames: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getUserAttributesByNames(user: number, attrNames: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getUserAttributesByNames(user: number, attrNames: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getUserAttributesByNames(user: number, attrNames: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getUserAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/u-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a UserExtSource Attribute by its id.
     * This is an overloaded method getAttribute, specialized for UserExtSource and attribute id.
     * @param userExtSource id of UserExtSource
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserExtSourceAttributeById(userExtSource: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getUserExtSourceAttributeById(userExtSource: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getUserExtSourceAttributeById(userExtSource: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getUserExtSourceAttributeById(userExtSource: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (userExtSource === null || userExtSource === undefined) {
            throw new Error('Required parameter userExtSource was null or undefined when calling getUserExtSourceAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getUserExtSourceAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (userExtSource !== undefined && userExtSource !== null) {
            queryParameters = queryParameters.set('userExtSource', <any>userExtSource);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-ues`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a UserExtSource Attribute by its name.
     * This is an overloaded method getAttribute, specialized for UserExtSource and attribute name.
     * @param userExtSource id of UserExtSource
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserExtSourceAttributeByName(userExtSource: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getUserExtSourceAttributeByName(userExtSource: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getUserExtSourceAttributeByName(userExtSource: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getUserExtSourceAttributeByName(userExtSource: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (userExtSource === null || userExtSource === undefined) {
            throw new Error('Required parameter userExtSource was null or undefined when calling getUserExtSourceAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getUserExtSourceAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (userExtSource !== undefined && userExtSource !== null) {
            queryParameters = queryParameters.set('userExtSource', <any>userExtSource);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-ues`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all non-empty attributes associated with the UserExtSource. 
     * @param userExtSource id of UserExtSource
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserExtSourceAttributes(userExtSource: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getUserExtSourceAttributes(userExtSource: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getUserExtSourceAttributes(userExtSource: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getUserExtSourceAttributes(userExtSource: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (userExtSource === null || userExtSource === undefined) {
            throw new Error('Required parameter userExtSource was null or undefined when calling getUserExtSourceAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (userExtSource !== undefined && userExtSource !== null) {
            queryParameters = queryParameters.set('userExtSource', <any>userExtSource);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/ues`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the userExtSource which have name in list attrNames (empty too). 
     * @param userExtSource id of UserExtSource
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserExtSourceAttributesByNames(userExtSource: number, attrNames: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getUserExtSourceAttributesByNames(userExtSource: number, attrNames: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getUserExtSourceAttributesByNames(userExtSource: number, attrNames: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getUserExtSourceAttributesByNames(userExtSource: number, attrNames: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (userExtSource === null || userExtSource === undefined) {
            throw new Error('Required parameter userExtSource was null or undefined when calling getUserExtSourceAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getUserExtSourceAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (userExtSource !== undefined && userExtSource !== null) {
            queryParameters = queryParameters.set('userExtSource', <any>userExtSource);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/ues-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a user_facility Attribute by its id.
     * This is an overloaded method getAttribute, specialized for user, facility and attribute id.
     * @param user id of User
     * @param facility id of Facility
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserFacilityAttributeById(user: number, facility: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getUserFacilityAttributeById(user: number, facility: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getUserFacilityAttributeById(user: number, facility: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getUserFacilityAttributeById(user: number, facility: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserFacilityAttributeById.');
        }
        if (facility === null || facility === undefined) {
            throw new Error('Required parameter facility was null or undefined when calling getUserFacilityAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getUserFacilityAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (facility !== undefined && facility !== null) {
            queryParameters = queryParameters.set('facility', <any>facility);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-user_facility`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a user_facility Attribute by its name.
     * This is an overloaded method getAttribute, specialized for user, facility and attribute name.
     * @param user id of User
     * @param facility id of Facility
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserFacilityAttributeByName(user: number, facility: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getUserFacilityAttributeByName(user: number, facility: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getUserFacilityAttributeByName(user: number, facility: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getUserFacilityAttributeByName(user: number, facility: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserFacilityAttributeByName.');
        }
        if (facility === null || facility === undefined) {
            throw new Error('Required parameter facility was null or undefined when calling getUserFacilityAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getUserFacilityAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (facility !== undefined && facility !== null) {
            queryParameters = queryParameters.set('facility', <any>facility);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-user_facility`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a Vo Attribute by its id.
     * This is an overloaded method getAttribute, specialized for virtual organization and attribute id.
     * @param vo id of Vo
     * @param attributeId id of AttributeDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVoAttributeById(vo: number, attributeId: number, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getVoAttributeById(vo: number, attributeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getVoAttributeById(vo: number, attributeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getVoAttributeById(vo: number, attributeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getVoAttributeById.');
        }
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getVoAttributeById.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
            queryParameters = queryParameters.set('vo', <any>vo);
        }
        if (attributeId !== undefined && attributeId !== null) {
            queryParameters = queryParameters.set('attributeId', <any>attributeId);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/id-vo`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a Vo Attribute by its name.
     * This is an overloaded method getAttribute, specialized for virtual organization and attribute name.
     * @param vo id of Vo
     * @param attributeName full name of attribute definition (namespace + \&#39;:\&#39; + friendlyName)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVoAttributeByName(vo: number, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Attribute>;
    public getVoAttributeByName(vo: number, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Attribute>>;
    public getVoAttributeByName(vo: number, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Attribute>>;
    public getVoAttributeByName(vo: number, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getVoAttributeByName.');
        }
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling getVoAttributeByName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
            queryParameters = queryParameters.set('vo', <any>vo);
        }
        if (attributeName !== undefined && attributeName !== null) {
            queryParameters = queryParameters.set('attributeName', <any>attributeName);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Attribute>(`${this.configuration.basePath}/json/attributesManager/getAttribute/name-vo`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the vo.
     * @param vo id of Vo
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVoAttributes(vo: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getVoAttributes(vo: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getVoAttributes(vo: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getVoAttributes(vo: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getVoAttributes.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
            queryParameters = queryParameters.set('vo', <any>vo);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/vo`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all attributes associated with the vo which have name in list attrNames (empty too).
     * @param vo id of Vo
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVoAttributesByNames(vo: number, attrNames: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Attribute>>;
    public getVoAttributesByNames(vo: number, attrNames: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Attribute>>>;
    public getVoAttributesByNames(vo: number, attrNames: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Attribute>>>;
    public getVoAttributesByNames(vo: number, attrNames: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getVoAttributesByNames.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getVoAttributesByNames.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
            queryParameters = queryParameters.set('vo', <any>vo);
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                queryParameters = queryParameters.append('attrNames[]', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Attribute>>(`${this.configuration.basePath}/json/attributesManager/getAttributes/vo-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets entityless Attribute.
     * @param inputEntitylessAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setEntitylessAttribute(inputEntitylessAttribute: InputEntitylessAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setEntitylessAttribute(inputEntitylessAttribute: InputEntitylessAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setEntitylessAttribute(inputEntitylessAttribute: InputEntitylessAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setEntitylessAttribute(inputEntitylessAttribute: InputEntitylessAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputEntitylessAttribute === null || inputEntitylessAttribute === undefined) {
            throw new Error('Required parameter inputEntitylessAttribute was null or undefined when calling setEntitylessAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/entityless`,
            inputEntitylessAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for Facility.
     * @param inputSetFacilityAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setFacilityAttribute(inputSetFacilityAttribute: InputSetFacilityAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setFacilityAttribute(inputSetFacilityAttribute: InputSetFacilityAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setFacilityAttribute(inputSetFacilityAttribute: InputSetFacilityAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setFacilityAttribute(inputSetFacilityAttribute: InputSetFacilityAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetFacilityAttribute === null || inputSetFacilityAttribute === undefined) {
            throw new Error('Required parameter inputSetFacilityAttribute was null or undefined when calling setFacilityAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/facility`,
            inputSetFacilityAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the facility. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetFacilityAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setFacilityAttributes(inputSetFacilityAttributes: InputSetFacilityAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setFacilityAttributes(inputSetFacilityAttributes: InputSetFacilityAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setFacilityAttributes(inputSetFacilityAttributes: InputSetFacilityAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setFacilityAttributes(inputSetFacilityAttributes: InputSetFacilityAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetFacilityAttributes === null || inputSetFacilityAttributes === undefined) {
            throw new Error('Required parameter inputSetFacilityAttributes was null or undefined when calling setFacilityAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/f`,
            inputSetFacilityAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the member, user, member-group, member-resource and user-facility attributes. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). Group and group-resource attributes are not supported in this context. 
     * @param inputSetFacilityResourceGroupUserMemberAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setFacilityResourceGroupUserMemberAttributes(inputSetFacilityResourceGroupUserMemberAttributes: InputSetFacilityResourceGroupUserMemberAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setFacilityResourceGroupUserMemberAttributes(inputSetFacilityResourceGroupUserMemberAttributes: InputSetFacilityResourceGroupUserMemberAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setFacilityResourceGroupUserMemberAttributes(inputSetFacilityResourceGroupUserMemberAttributes: InputSetFacilityResourceGroupUserMemberAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setFacilityResourceGroupUserMemberAttributes(inputSetFacilityResourceGroupUserMemberAttributes: InputSetFacilityResourceGroupUserMemberAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetFacilityResourceGroupUserMemberAttributes === null || inputSetFacilityResourceGroupUserMemberAttributes === undefined) {
            throw new Error('Required parameter inputSetFacilityResourceGroupUserMemberAttributes was null or undefined when calling setFacilityResourceGroupUserMemberAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/f-r-g-u-m`,
            inputSetFacilityResourceGroupUserMemberAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the member, user, member-resource and user-facility attributes. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetFacilityResourceUserMemberAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setFacilityResourceUserMemberAttributes(inputSetFacilityResourceUserMemberAttributes: InputSetFacilityResourceUserMemberAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setFacilityResourceUserMemberAttributes(inputSetFacilityResourceUserMemberAttributes: InputSetFacilityResourceUserMemberAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setFacilityResourceUserMemberAttributes(inputSetFacilityResourceUserMemberAttributes: InputSetFacilityResourceUserMemberAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setFacilityResourceUserMemberAttributes(inputSetFacilityResourceUserMemberAttributes: InputSetFacilityResourceUserMemberAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetFacilityResourceUserMemberAttributes === null || inputSetFacilityResourceUserMemberAttributes === undefined) {
            throw new Error('Required parameter inputSetFacilityResourceUserMemberAttributes was null or undefined when calling setFacilityResourceUserMemberAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/f-r-u-m`,
            inputSetFacilityResourceUserMemberAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the facility and user combination. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetFacilityUserAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setFacilityUserAttributes(inputSetFacilityUserAttributes: InputSetFacilityUserAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setFacilityUserAttributes(inputSetFacilityUserAttributes: InputSetFacilityUserAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setFacilityUserAttributes(inputSetFacilityUserAttributes: InputSetFacilityUserAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setFacilityUserAttributes(inputSetFacilityUserAttributes: InputSetFacilityUserAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetFacilityUserAttributes === null || inputSetFacilityUserAttributes === undefined) {
            throw new Error('Required parameter inputSetFacilityUserAttributes was null or undefined when calling setFacilityUserAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/f-u`,
            inputSetFacilityUserAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for Group.
     * @param inputSetGroupAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setGroupAttribute(inputSetGroupAttribute: InputSetGroupAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setGroupAttribute(inputSetGroupAttribute: InputSetGroupAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setGroupAttribute(inputSetGroupAttribute: InputSetGroupAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setGroupAttribute(inputSetGroupAttribute: InputSetGroupAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetGroupAttribute === null || inputSetGroupAttribute === undefined) {
            throw new Error('Required parameter inputSetGroupAttribute was null or undefined when calling setGroupAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/group`,
            inputSetGroupAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the group. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetGroupAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setGroupAttributes(inputSetGroupAttributes: InputSetGroupAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setGroupAttributes(inputSetGroupAttributes: InputSetGroupAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setGroupAttributes(inputSetGroupAttributes: InputSetGroupAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setGroupAttributes(inputSetGroupAttributes: InputSetGroupAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetGroupAttributes === null || inputSetGroupAttributes === undefined) {
            throw new Error('Required parameter inputSetGroupAttributes was null or undefined when calling setGroupAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/g`,
            inputSetGroupAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for Group and Resource.
     * @param inputSetGroupResourceAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setGroupResourceAttribute(inputSetGroupResourceAttribute: InputSetGroupResourceAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setGroupResourceAttribute(inputSetGroupResourceAttribute: InputSetGroupResourceAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setGroupResourceAttribute(inputSetGroupResourceAttribute: InputSetGroupResourceAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setGroupResourceAttribute(inputSetGroupResourceAttribute: InputSetGroupResourceAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetGroupResourceAttribute === null || inputSetGroupResourceAttribute === undefined) {
            throw new Error('Required parameter inputSetGroupResourceAttribute was null or undefined when calling setGroupResourceAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/group-resource`,
            inputSetGroupResourceAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for Host.
     * @param inputSetHostAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setHostAttribute(inputSetHostAttribute: InputSetHostAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setHostAttribute(inputSetHostAttribute: InputSetHostAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setHostAttribute(inputSetHostAttribute: InputSetHostAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setHostAttribute(inputSetHostAttribute: InputSetHostAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetHostAttribute === null || inputSetHostAttribute === undefined) {
            throw new Error('Required parameter inputSetHostAttribute was null or undefined when calling setHostAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/host`,
            inputSetHostAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the host. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetHostAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setHostAttributes(inputSetHostAttributes: InputSetHostAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setHostAttributes(inputSetHostAttributes: InputSetHostAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setHostAttributes(inputSetHostAttributes: InputSetHostAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setHostAttributes(inputSetHostAttributes: InputSetHostAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetHostAttributes === null || inputSetHostAttributes === undefined) {
            throw new Error('Required parameter inputSetHostAttributes was null or undefined when calling setHostAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/h`,
            inputSetHostAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for Member.
     * @param inputSetMemberAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMemberAttribute(inputSetMemberAttribute: InputSetMemberAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMemberAttribute(inputSetMemberAttribute: InputSetMemberAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMemberAttribute(inputSetMemberAttribute: InputSetMemberAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMemberAttribute(inputSetMemberAttribute: InputSetMemberAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetMemberAttribute === null || inputSetMemberAttribute === undefined) {
            throw new Error('Required parameter inputSetMemberAttribute was null or undefined when calling setMemberAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/member`,
            inputSetMemberAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the member. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetMemberAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMemberAttributes(inputSetMemberAttributes: InputSetMemberAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMemberAttributes(inputSetMemberAttributes: InputSetMemberAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMemberAttributes(inputSetMemberAttributes: InputSetMemberAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMemberAttributes(inputSetMemberAttributes: InputSetMemberAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetMemberAttributes === null || inputSetMemberAttributes === undefined) {
            throw new Error('Required parameter inputSetMemberAttributes was null or undefined when calling setMemberAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/m`,
            inputSetMemberAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for Member and Group.
     * @param inputSetMemberGroupAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMemberGroupAttribute(inputSetMemberGroupAttribute: InputSetMemberGroupAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMemberGroupAttribute(inputSetMemberGroupAttribute: InputSetMemberGroupAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMemberGroupAttribute(inputSetMemberGroupAttribute: InputSetMemberGroupAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMemberGroupAttribute(inputSetMemberGroupAttribute: InputSetMemberGroupAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetMemberGroupAttribute === null || inputSetMemberGroupAttribute === undefined) {
            throw new Error('Required parameter inputSetMemberGroupAttribute was null or undefined when calling setMemberGroupAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/member-group`,
            inputSetMemberGroupAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the member and group combination. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetMemberGroupAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMemberGroupAttributes(inputSetMemberGroupAttributes: InputSetMemberGroupAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMemberGroupAttributes(inputSetMemberGroupAttributes: InputSetMemberGroupAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMemberGroupAttributes(inputSetMemberGroupAttributes: InputSetMemberGroupAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMemberGroupAttributes(inputSetMemberGroupAttributes: InputSetMemberGroupAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetMemberGroupAttributes === null || inputSetMemberGroupAttributes === undefined) {
            throw new Error('Required parameter inputSetMemberGroupAttributes was null or undefined when calling setMemberGroupAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/m-g`,
            inputSetMemberGroupAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the member and group combination. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). If workWithUserAttributes is true, the method stores also the attributes associated with user and member. 
     * @param inputSetMemberGroupWithUserAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMemberGroupWithUserAttributes(inputSetMemberGroupWithUserAttributes: InputSetMemberGroupWithUserAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMemberGroupWithUserAttributes(inputSetMemberGroupWithUserAttributes: InputSetMemberGroupWithUserAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMemberGroupWithUserAttributes(inputSetMemberGroupWithUserAttributes: InputSetMemberGroupWithUserAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMemberGroupWithUserAttributes(inputSetMemberGroupWithUserAttributes: InputSetMemberGroupWithUserAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetMemberGroupWithUserAttributes === null || inputSetMemberGroupWithUserAttributes === undefined) {
            throw new Error('Required parameter inputSetMemberGroupWithUserAttributes was null or undefined when calling setMemberGroupWithUserAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/m-g-wu`,
            inputSetMemberGroupWithUserAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the resource and member combination. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). If workWithUserAttributes is true, the method stores also the attributes associated with user, user-facility and member. 
     * @param inputSetMemberResourceAndUserAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMemberResourceAndUserAttributes(inputSetMemberResourceAndUserAttributes: InputSetMemberResourceAndUserAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMemberResourceAndUserAttributes(inputSetMemberResourceAndUserAttributes: InputSetMemberResourceAndUserAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMemberResourceAndUserAttributes(inputSetMemberResourceAndUserAttributes: InputSetMemberResourceAndUserAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMemberResourceAndUserAttributes(inputSetMemberResourceAndUserAttributes: InputSetMemberResourceAndUserAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetMemberResourceAndUserAttributes === null || inputSetMemberResourceAndUserAttributes === undefined) {
            throw new Error('Required parameter inputSetMemberResourceAndUserAttributes was null or undefined when calling setMemberResourceAndUserAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/m-r-wu`,
            inputSetMemberResourceAndUserAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for Member and Resource.
     * @param inputSetMemberResourceAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMemberResourceAttribute(inputSetMemberResourceAttribute: InputSetMemberResourceAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMemberResourceAttribute(inputSetMemberResourceAttribute: InputSetMemberResourceAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMemberResourceAttribute(inputSetMemberResourceAttribute: InputSetMemberResourceAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMemberResourceAttribute(inputSetMemberResourceAttribute: InputSetMemberResourceAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetMemberResourceAttribute === null || inputSetMemberResourceAttribute === undefined) {
            throw new Error('Required parameter inputSetMemberResourceAttribute was null or undefined when calling setMemberResourceAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/member-resource`,
            inputSetMemberResourceAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the resource and member combination. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetMemberResourceAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMemberResourceAttributes(inputSetMemberResourceAttributes: InputSetMemberResourceAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMemberResourceAttributes(inputSetMemberResourceAttributes: InputSetMemberResourceAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMemberResourceAttributes(inputSetMemberResourceAttributes: InputSetMemberResourceAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMemberResourceAttributes(inputSetMemberResourceAttributes: InputSetMemberResourceAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetMemberResourceAttributes === null || inputSetMemberResourceAttributes === undefined) {
            throw new Error('Required parameter inputSetMemberResourceAttributes was null or undefined when calling setMemberResourceAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/m-r`,
            inputSetMemberResourceAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with member and user (which we get from this member) if workWithUserAttributes is true. 
     * @param inputSetMemberWithUserAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMemberWithUserAttributes(inputSetMemberWithUserAttributes: InputSetMemberWithUserAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMemberWithUserAttributes(inputSetMemberWithUserAttributes: InputSetMemberWithUserAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMemberWithUserAttributes(inputSetMemberWithUserAttributes: InputSetMemberWithUserAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMemberWithUserAttributes(inputSetMemberWithUserAttributes: InputSetMemberWithUserAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetMemberWithUserAttributes === null || inputSetMemberWithUserAttributes === undefined) {
            throw new Error('Required parameter inputSetMemberWithUserAttributes was null or undefined when calling setMemberWithUserAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/m-wu`,
            inputSetMemberWithUserAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for Resource.
     * @param inputSetResourceAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setResourceAttribute(inputSetResourceAttribute: InputSetResourceAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setResourceAttribute(inputSetResourceAttribute: InputSetResourceAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setResourceAttribute(inputSetResourceAttribute: InputSetResourceAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setResourceAttribute(inputSetResourceAttribute: InputSetResourceAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetResourceAttribute === null || inputSetResourceAttribute === undefined) {
            throw new Error('Required parameter inputSetResourceAttribute was null or undefined when calling setResourceAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/resource`,
            inputSetResourceAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the resource. 
     * @param inputSetResourceAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setResourceAttributes(inputSetResourceAttributes: InputSetResourceAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setResourceAttributes(inputSetResourceAttributes: InputSetResourceAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setResourceAttributes(inputSetResourceAttributes: InputSetResourceAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setResourceAttributes(inputSetResourceAttributes: InputSetResourceAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetResourceAttributes === null || inputSetResourceAttributes === undefined) {
            throw new Error('Required parameter inputSetResourceAttributes was null or undefined when calling setResourceAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/r`,
            inputSetResourceAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the group on resource. 
     * @param inputSetResourceGroupAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setResourceGroupAttributes(inputSetResourceGroupAttributes: InputSetResourceGroupAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setResourceGroupAttributes(inputSetResourceGroupAttributes: InputSetResourceGroupAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setResourceGroupAttributes(inputSetResourceGroupAttributes: InputSetResourceGroupAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setResourceGroupAttributes(inputSetResourceGroupAttributes: InputSetResourceGroupAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetResourceGroupAttributes === null || inputSetResourceGroupAttributes === undefined) {
            throw new Error('Required parameter inputSetResourceGroupAttributes was null or undefined when calling setResourceGroupAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/r-g`,
            inputSetResourceGroupAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with group and resource, if workWithUserAttributes is true then also from group itself. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetResourceGroupWithGroupAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setResourceGroupWithGroupAttributes(inputSetResourceGroupWithGroupAttributes: InputSetResourceGroupWithGroupAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setResourceGroupWithGroupAttributes(inputSetResourceGroupWithGroupAttributes: InputSetResourceGroupWithGroupAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setResourceGroupWithGroupAttributes(inputSetResourceGroupWithGroupAttributes: InputSetResourceGroupWithGroupAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setResourceGroupWithGroupAttributes(inputSetResourceGroupWithGroupAttributes: InputSetResourceGroupWithGroupAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetResourceGroupWithGroupAttributes === null || inputSetResourceGroupWithGroupAttributes === undefined) {
            throw new Error('Required parameter inputSetResourceGroupWithGroupAttributes was null or undefined when calling setResourceGroupWithGroupAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/r-g-wg`,
            inputSetResourceGroupWithGroupAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for User.
     * @param inputSetUserAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setUserAttribute(inputSetUserAttribute: InputSetUserAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setUserAttribute(inputSetUserAttribute: InputSetUserAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setUserAttribute(inputSetUserAttribute: InputSetUserAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setUserAttribute(inputSetUserAttribute: InputSetUserAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetUserAttribute === null || inputSetUserAttribute === undefined) {
            throw new Error('Required parameter inputSetUserAttribute was null or undefined when calling setUserAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/user`,
            inputSetUserAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the user. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetUserAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setUserAttributes(inputSetUserAttributes: InputSetUserAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setUserAttributes(inputSetUserAttributes: InputSetUserAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setUserAttributes(inputSetUserAttributes: InputSetUserAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setUserAttributes(inputSetUserAttributes: InputSetUserAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetUserAttributes === null || inputSetUserAttributes === undefined) {
            throw new Error('Required parameter inputSetUserAttributes was null or undefined when calling setUserAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/u`,
            inputSetUserAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for UserExtSource.
     * @param inputSetUserExtSourceAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setUserExtSourceAttribute(inputSetUserExtSourceAttribute: InputSetUserExtSourceAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setUserExtSourceAttribute(inputSetUserExtSourceAttribute: InputSetUserExtSourceAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setUserExtSourceAttribute(inputSetUserExtSourceAttribute: InputSetUserExtSourceAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setUserExtSourceAttribute(inputSetUserExtSourceAttribute: InputSetUserExtSourceAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetUserExtSourceAttribute === null || inputSetUserExtSourceAttribute === undefined) {
            throw new Error('Required parameter inputSetUserExtSourceAttribute was null or undefined when calling setUserExtSourceAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/userExtSource`,
            inputSetUserExtSourceAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the UserExtSource. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetUserExtSourceAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setUserExtSourceAttributes(inputSetUserExtSourceAttributes: InputSetUserExtSourceAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setUserExtSourceAttributes(inputSetUserExtSourceAttributes: InputSetUserExtSourceAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setUserExtSourceAttributes(inputSetUserExtSourceAttributes: InputSetUserExtSourceAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setUserExtSourceAttributes(inputSetUserExtSourceAttributes: InputSetUserExtSourceAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetUserExtSourceAttributes === null || inputSetUserExtSourceAttributes === undefined) {
            throw new Error('Required parameter inputSetUserExtSourceAttributes was null or undefined when calling setUserExtSourceAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/ues`,
            inputSetUserExtSourceAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for User and Facility.
     * @param inputSetUserFacilityAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setUserFacilityAttribute(inputSetUserFacilityAttribute: InputSetUserFacilityAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setUserFacilityAttribute(inputSetUserFacilityAttribute: InputSetUserFacilityAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setUserFacilityAttribute(inputSetUserFacilityAttribute: InputSetUserFacilityAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setUserFacilityAttribute(inputSetUserFacilityAttribute: InputSetUserFacilityAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetUserFacilityAttribute === null || inputSetUserFacilityAttribute === undefined) {
            throw new Error('Required parameter inputSetUserFacilityAttribute was null or undefined when calling setUserFacilityAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/facility-user`,
            inputSetUserFacilityAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets Attribute for Vo.
     * @param inputSetVoAttribute 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setVoAttribute(inputSetVoAttribute: InputSetVoAttribute, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setVoAttribute(inputSetVoAttribute: InputSetVoAttribute, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setVoAttribute(inputSetVoAttribute: InputSetVoAttribute, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setVoAttribute(inputSetVoAttribute: InputSetVoAttribute, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetVoAttribute === null || inputSetVoAttribute === undefined) {
            throw new Error('Required parameter inputSetVoAttribute was null or undefined when calling setVoAttribute.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttribute/vo`,
            inputSetVoAttribute,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Store the attributes associated with the vo. If an attribute is core attribute then the attribute isn\&#39;t stored (It\&#39;s skipped without any notification). 
     * @param inputSetVoAttributes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setVoAttributes(inputSetVoAttributes: InputSetVoAttributes, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setVoAttributes(inputSetVoAttributes: InputSetVoAttributes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setVoAttributes(inputSetVoAttributes: InputSetVoAttributes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setVoAttributes(inputSetVoAttributes: InputSetVoAttributes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (inputSetVoAttributes === null || inputSetVoAttributes === undefined) {
            throw new Error('Required parameter inputSetVoAttributes was null or undefined when calling setVoAttributes.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/json/attributesManager/setAttributes/vo`,
            inputSetVoAttributes,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
